#!/usr/bin/perl
#
# Re-generate an ELF file at the specified offset
# with the symbols provided from the IDA Pro dump.
#
use warnings;
use strict;
use Getopt::Long;
use File::Temp qw/ tempfile tempdir /;

my $base	= 0;
my $output	= "a.out";
my $cc		= $ENV{CC} || "gcc";
my $syms;
my $image;

GetOptions(
	"b|base=o"		=> \$base,
	"s|syms=s"		=> \$syms,
	"i|image=s"		=> \$image,
	"o|output=s"		=> \$output,
	"c|cc=s"		=> \$cc,
) or die "$0: Unknown option\n";

die "$0: Image must be specified!\n" unless $image;
warn "$0: No syms?\n" unless $syms;


# Convert the base back into hex notation
$base = sprintf "0x%08x", $base;

open SYMS, "<", $syms
	or die "$0: Unable to open syms file '$syms': $!\n";

my $dir = tempdir( CLEANUP => 1 );
my ($fh,$asm_file) = tempfile( DIR => $dir, SUFFIX => ".S" );


#
# Output the preamble of the temporary .S file
#
print $fh <<"";
/*
 * Generated file from $image.
 * Do not edit!
 */
.text
.org 0
.align 2
.globl _start
here = .
#define NSTUB(addr,name) name = here + addr - $base
_start:
.text


#
# Parse the symbol dump from IDA Pro and output
# code into the .S file to define stubs for each of the
# entities.
#
while( <SYMS> )
{
	my ($addr,$name) = /^\s0001:([0-9A-F]+)\s+([^\s]+)\s*$/
                        or next;
	$addr = hex($addr) + hex($base);

	printf $fh "NSTUB( 0x%08x, %s )\n", $addr, $name;
}


#
# Include the ROM dump into the ELF file
#
print $fh <<"";
blob:
.incbin "$image"
end:

close SYMS;
close $fh;

#
# Call $CC to compile the assembly file
#
system $cc,
	"-Wl,-N,-Ttext,$base",
	"-nostdlib",
	"-o"	=> $output,
	$asm_file;
